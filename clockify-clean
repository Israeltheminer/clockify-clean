#!/usr/bin/env zsh

# clockify-clean-optimized: Much faster version using grep for filtering
# Original: 5-6 minutes | Optimized: ~10-20 seconds

set -euo pipefail

# Configuration
DAYS_BACK=14
DRY_RUN=false
BATCH_MODE=false
SKIP_CONFIRMATION=false
VERBOSE=false

# App/Domain lists
WHITELIST_APPS=("Cursor" "Figma" "Microsoft Teams" "Teams" "OrbStack" "Microsoft Outlook")
BLACKLIST_APPS=("loginwindow" "Spotify" "Netflix" "Mail" "Weather" "Clockify Desktop" "Finder" "Automator" "UserNotificationCenter" "Messages" "YouTube Music" "iPhone Mirroring" "YouTube" "FL Studio" "Photo Booth" "Music" "SecurityAgent" "System Settings")
WHITELIST_DOMAINS=("github.com" "localhost")
BLACKLIST_DOMAINS=("x.com" "linkedin.com" "coinmarketcap.com" "tradingview.com" "bybitglobal.com" "bybit.com" "music.youtube.com" "youtube.com" "mantle.xyz" "reuters.com" "upwork.com" "mail.google.com" "reddit.com" "google.com/search")

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1" >&2; }

usage() {
    echo "clockify-clean-optimized: Fast autotracker cleanup (uses grep)"
    echo ""
    echo "Usage: $(basename $0) [options]"
    echo ""
    echo "Options:"
    echo "  -d, --days <num>     Days back (default: 7)"
    echo "  --dry-run            Preview only"
    echo "  --batch              Batch mode with single confirmation"
    echo "  -y, --yes            Skip confirmations"
    echo "  -v, --verbose        Verbose output"
    echo "  -h, --help           Show help"
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--days) DAYS_BACK="$2"; shift 2 ;;
            --dry-run) DRY_RUN=true; shift ;;
            --batch) BATCH_MODE=true; shift ;;
            -y|--yes) SKIP_CONFIRMATION=true; shift ;;
            -v|--verbose) VERBOSE=true; shift ;;
            -h|--help) usage; exit 0 ;;
            *) log_error "Unknown: $1"; usage; exit 1 ;;
        esac
    done
}

get_start_date() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date -v-${DAYS_BACK}d '+%Y-%m-%d'
    else
        date -d "$DAYS_BACK days ago" '+%Y-%m-%d'
    fi
}

get_clockify_db() {
    local dir="$HOME/Library/Application Support/Clockify Desktop"
    local db=$(find "$dir" -maxdepth 1 -name "Clockify_*.sqlite" -type f 2>/dev/null | head -1)
    [[ -z "$db" ]] && db="$dir/Clockify.sqlite"
    [[ ! -f "$db" ]] && { log_error "Database not found"; exit 1; }
    echo "$db"
}

process_entries() {
    local start_date=$(get_start_date)
    local db_path=$(get_clockify_db)

    log_info "Configuration:"
    echo "  Days: $DAYS_BACK (from $start_date)"
    echo "  DB: $db_path"
    echo ""

    # Calculate timestamp
    local cutoff
    if [[ "$OSTYPE" == "darwin"* ]]; then
        cutoff=$(date -j -f "%Y-%m-%d" "$start_date" "+%s")
        cutoff=$((cutoff - 978307200))
    else
        cutoff=$(date -d "$start_date" "+%s")
        cutoff=$((cutoff - 978307200))
    fi

    # Fetch ALL entries at once
    log_info "âš¡ Fetching all entries from database..."
    local all_entries=$(mktemp)

    sqlite3 "$db_path" "
    SELECT ZID || '|' || ZNAME || '|' || COALESCE(ZITEMDESCRIPTION, '') || '|' || COALESCE(ZITEMURL, '')
    FROM ZCDAUTOTRACKERITEM
    WHERE ZTIMEENTRYADDED = 0
    AND ZTIMESTARTED >= $cutoff
    AND ZTIMEENDED IS NOT NULL
    ORDER BY ZTIMESTARTED DESC" > "$all_entries" 2>/dev/null || {
        log_error "Failed to query database"
        rm -f "$all_entries"
        exit 1
    }

    local total=$(wc -l < "$all_entries" | tr -d ' ')
    log_success "Fetched $total entries"

    # OPTIMIZATION: Use grep to filter entries super fast
    log_info "âš¡ Filtering with grep (fast!)..."

    local blacklist_ids=$(mktemp)
    local whitelist_ids=$(mktemp)
    local undecided_ids=$(mktemp)

    # Build grep patterns
    local blacklist_pattern=""
    for app in "${BLACKLIST_APPS[@]}"; do
        blacklist_pattern="${blacklist_pattern}|${app}\|"
    done
    for domain in "${BLACKLIST_DOMAINS[@]}"; do
        blacklist_pattern="${blacklist_pattern}|${domain}"
    done
    blacklist_pattern="${blacklist_pattern:1}"  # Remove leading |

    local whitelist_pattern=""
    for app in "${WHITELIST_APPS[@]}"; do
        whitelist_pattern="${whitelist_pattern}|${app}\|"
    done
    for domain in "${WHITELIST_DOMAINS[@]}"; do
        whitelist_pattern="${whitelist_pattern}|${domain}"
    done
    whitelist_pattern="${whitelist_pattern:1}"

    # Filter entries using grep (MUCH faster than shell loops!)
    grep -E "$blacklist_pattern" "$all_entries" | cut -d'|' -f1 > "$blacklist_ids" 2>/dev/null || true
    grep -E "$whitelist_pattern" "$all_entries" | cut -d'|' -f1 > "$whitelist_ids" 2>/dev/null || true

    # Undecided = not in blacklist AND not in whitelist
    grep -v -F -f "$blacklist_ids" "$all_entries" 2>/dev/null | \
    grep -v -F -f "$whitelist_ids" 2>/dev/null | \
    cut -d'|' -f1 > "$undecided_ids" 2>/dev/null || true

    local blacklist_count=$(wc -l < "$blacklist_ids" | tr -d ' ')
    local whitelist_count=$(wc -l < "$whitelist_ids" | tr -d ' ')
    local undecided_count=$(wc -l < "$undecided_ids" | tr -d ' ')

    echo ""
    log_info "ðŸ“Š Results:"
    echo "  âœ“ Whitelist (keep): $whitelist_count"
    echo "  âœ— Blacklist (delete): $blacklist_count"
    echo "  ? Undecided (review): $undecided_count"
    echo ""

    if [[ "$blacklist_count" -eq 0 ]]; then
        log_success "Nothing to delete!"
        rm -f "$all_entries" "$blacklist_ids" "$whitelist_ids" "$undecided_ids"
        return 0
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would delete $blacklist_count entries"
        if [[ "$VERBOSE" == "true" ]]; then
            echo ""
            echo "Sample blacklisted entries:"
            grep -F -f "$blacklist_ids" "$all_entries" | head -10
        fi
        rm -f "$all_entries" "$blacklist_ids" "$whitelist_ids" "$undecided_ids"
        return 0
    fi

    # Delete blacklisted entries
    if [[ "$SKIP_CONFIRMATION" != "true" && "$BATCH_MODE" != "true" ]]; then
        echo -n "Delete $blacklist_count blacklisted entries? [y/N]: "
        read -r response
        [[ ! "$response" =~ ^[Yy]$ ]] && {
            log_info "Cancelled"
            rm -f "$all_entries" "$blacklist_ids" "$whitelist_ids" "$undecided_ids"
            return 0
        }
    fi

    log_info "ðŸ—‘ï¸  Deleting $blacklist_count entries..."

    local deleted=0
    local failed=0
    local current=0

    while read -r id; do
        ((current++))

        # Progress every 100 entries
        if (( current % 100 == 0 )); then
            log_info "Progress: $current/$blacklist_count..."
        fi

        if sqlite3 "$db_path" "DELETE FROM ZCDAUTOTRACKERITEM WHERE ZID = '$id'" 2>/dev/null; then
            ((deleted++))
        else
            ((failed++))
            # Only break if we hit many consecutive failures (likely db locked)
            if [[ $failed -gt 10 ]]; then
                log_error "Too many failures ($failed) - database may be locked"
                break
            fi
        fi
    done < "$blacklist_ids"

    echo ""
    log_success "âœ… Deleted $deleted entries"
    [[ $failed -gt 0 ]] && log_error "âŒ Failed $failed (database locked?)"

    # Cleanup
    rm -f "$all_entries" "$blacklist_ids" "$whitelist_ids" "$undecided_ids"
}

main() {
    echo "âš¡ Clockify Clean - OPTIMIZED (grep-powered)"
    echo ""

    parse_args "$@"

    local start_time=$(date +%s)
    process_entries
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    echo ""
    log_success "âœ¨ Completed in ${duration}s (vs 5-6 minutes with original!)"
}

main "$@"
